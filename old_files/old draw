// before 10.5.2 update
function draw(){
  if (window.__splashActive || !window.__playerReady) return; // do nothing until after login
  fitCanvasToViewport();
  // Read the dynamic background color from our CSS variable
  const bgColor = getComputedStyle(document.body).getPropertyValue('--mood-background-color');
  
  // Use p5.js to paint the background with that color
  background(color(bgColor));

  // Draw the emoji directly on the canvas ---
  if (isMoodMode()) {
    const emo = dominantEmotion();
    let emojiChar = '';
    if (emo === 'happy') emojiChar = 'ðŸ˜Š';
    if (emo === 'sad') emojiChar = 'ðŸ˜¢';
    if (emo === 'angry') emojiChar = 'ðŸ˜ ';
    if (emo === 'stressed') emojiChar = 'ðŸ˜Ÿ';
    
    if (emojiChar) {
      textAlign(CENTER, CENTER);
      textSize(Math.min(width, height) * 0.5); // Make it huge
      fill(0, 0, 0, 8); // Black, but very faint (8 out of 255 opacity)
      text(emojiChar, width / 2, height / 2);
    }
  }

  // Classic mode timer setting
  let timeLeft;
  if (currentMode === 'classic'){
    if (classicDeadline){
      timeLeft = Math.max(0, Math.ceil((classicDeadline - Date.now())/1000));
    } else {
      timeLeft = null; // relax
    }
  } else {
    timeLeft = Math.max(0, GAME_DURATION - Math.floor((millis() - startTime)/1000));
  }

  const timeChip = document.getElementById('timeChip');
  if (timeChip){
    if (timeLeft == null){
      timeChip.textContent = 'Time: âˆž';   // Relax mode
    } else {
      timeChip.textContent = `Time: ${timeLeft}`;
    }
  }

  document.getElementById('scoreChip').textContent = `Score: ${score}`;


  const modeChip = document.getElementById('modeChip');
  if (modeChip){
    const label = (currentMode === 'classic') ? 'Zen'
                : (currentMode === 'challenge') ? 'Focus'
                : 'Emotion';
    // Always keep the text current
    modeChip.textContent = `Mode: ${label}`;
    modeChip.style.display = 'inline-flex';   // always visible
  }

  const moodChip  = document.getElementById('moodChip');
  const camBtnEl = document.getElementById('cameraBtn');
  let modeSpeedMult = 1.0;

  if (currentMode === 'classic'){   // Classic mode
    modeSpeedMult = CLASSIC_SPEED_SCALE;
    moodChip?.classList.add('hiddenChip');
    if (camBtnEl) camBtnEl.style.display = 'none';
  } else if (currentMode === 'challenge'){ // Challenge mode
    modeSpeedMult = 1.3;
    moodChip?.classList.add('hiddenChip');
    if (camBtnEl) camBtnEl.style.display = 'none';
  } else { // Mood mode
    refreshCameraBtn();
    moodChip?.classList.remove('hiddenChip');

    const emo = dominantEmotion();
    moodChip.textContent = emo.toUpperCase();

    // Define mood properties for background, emoji, speed, and scoring
    let moodConfig = {
      bgColor: '#f3f4f6', // NEW: Light gray for Neutral
      chipColor: '#e5e7eb',
      emoji: '', // No emoji for neutral
      speedMult: 1.0,
    };

    if (emo === 'happy') {
      moodConfig = { bgColor: '#dcfce7', chipColor: '#a7f3d0', emoji: 'ðŸ˜Š', speedMult: 1.3 };
    } else if (emo === 'sad') {
      moodConfig = { bgColor: '#bfdbfe', chipColor: '#93c5fd', emoji: 'ðŸ˜¢', speedMult: 0.8 }; // NEW: More distinct blue
    } else if (emo === 'angry') {
      moodConfig = { bgColor: '#fee2e2', chipColor: '#fca5a5', emoji: 'ðŸ˜ ', speedMult: 1.0 };
    } else if (emo === 'stressed') {
      moodConfig = { bgColor: '#fef3c7', chipColor: '#fde047', emoji: 'ðŸ˜Ÿ', speedMult: 0.6 };
    }

    // Apply the color to the moodChip
    moodChip.style.background = moodConfig.chipColor;

    // Apply the changes to the CSS variables
    document.body.style.setProperty('--mood-background-color', moodConfig.bgColor);
    document.body.style.setProperty('--mood-emoji-url', moodConfig.emoji);

    // Set the speed multiplier for the bubbles
    modeSpeedMult = moodConfig.speedMult;
  }

  const sTop = safeTopPx();
  const MINF = MIN_PLAY_SPEED;

  // Guard against uninitialized bubbles & surface errors instead of hard-crashing the frame
  if (!bubbles || typeof bubbles.length !== 'number') return;

  try {

    for (let i = 0; i < bubbles.length; i++){
      const b = bubbles[i];

      // === Pop animation check ===
      if (b._popping) {
        const elapsed = (millis ? millis() : Date.now()) - (b._popStart || 0);
        const t = Math.min(1, elapsed / 200); // 200ms animation

        const r = currentRadius(b) * (1 - t);
        const d = r * 2;
        const alpha = 200 * (1 - t);

        fill(red(b._tint), green(b._tint), blue(b._tint), alpha);
        circle(b.x, b.y, d);

        if (t >= 1) {
          if (b._respawnAfterPop) {
            if (typeof b.remove === 'function') b.remove();
            spawnBubble();
            b._respawnAfterPop = false;
          } else {
            if (typeof b.remove === 'function') b.remove();
          }
          b._popping = false;
        }

        continue; // ðŸ”‘ skip normal drawing for this bubble
      }

      // --- v10.0.0 Step 3C: Classic draw & dead-skip ---
      if (currentMode === 'classic') {
        // If we already "popped" it in classic, don't draw or move it
        if (b.alive === false) continue;

        // Force a single tint for normal bubbles, and red for penalties
        // (we bypass the usual palette/trick tints)
        b._tint = (b.kind === 'trick') ? color(...COLOR_RED) : color(...COLOR_TEAL);
      }

      // Skip movement in Classic static mode
      if (currentMode !== 'classic' || !window.__classicStatic) {
        b.direction += random(-0.35, 0.35);
        const r = currentRadius(b);

        if (currentMode === 'classic')      b.speed = max(min(b._baseSpeed * modeSpeedMult * rubberSpeedFactor(), CLASSIC_SPEED_CAP), MINF);
        else if (currentMode === 'challenge') b.speed = max(b._baseSpeed * modeSpeedMult * rubberSpeedFactor(), MINF);
        else                                  b.speed = max(b._baseSpeed * constrain(modeSpeedMult, 0.5, 1.6) * rubberSpeedFactor(), MINF);

        if (b.x < r){ b.x = r + 0.5; b.direction = 180 - b.direction; b.direction += random(-1.5,1.5); }
        if (b.x > width - r){ b.x = width - r - 0.5; b.direction = 180 - b.direction; b.direction += random(-1.5,1.5); }
        if (b.y < sTop + r){ b.y = sTop + r + 0.5; b.direction = 360 - b.direction; b.direction += random(-1.5,1.5); }
        if (b.y > height - r){ b.y = height - r - 0.5; b.direction = 360 - b.direction; b.direction += random(-1.5,1.5); }

        const d = r * 2;
        fill(b._tint);
        circle(b.x, b.y, d);
        fill(255,255,255,60);
        circle(b.x - d*0.2, b.y - d*0.2, d*0.4);

        if (b._stuck == null) b._stuck = 0;
        if (b.speed < 0.15) b._stuck++; else b._stuck = 0;
        if (b._stuck > 18){
          b.direction = random(360); b.speed = max(b._baseSpeed * 1.05, MINF + 0.2);
          if (b.y - r <= sTop + 1) b.y = sTop + r + 2; else if (b.y + r >= height - 1) b.y = height - r - 2;
          if (b.x - r <= 1) b.x = r + 2; else if (b.x + r >= width - 1) b.x = width - r - 2;
          b._stuck = 0;
        }
      }

      // NEW: Classic draw when movement is skipped
      if (currentMode === 'classic') {
        const r = currentRadius(b), d = r * 2;
        fill(b._tint);           // you set this earlier based on (b.kind === 'trick')
        circle(b.x, b.y, d);
        fill(255,255,255,60);    // highlight
        circle(b.x - d*0.2, b.y - d*0.2, d*0.4);
      }
    }
  } catch (err) {
    console.warn('[draw] bubble loop error:', err);
  }

  if (!gameOver && timeLeft != null && timeLeft <= 0) endGame();

  // Classic end logic:
  // - RELAX (endless): when all teal are popped, rebuild a fresh board and keep playing.
  // - TIMED: when the clock expires, end the round.
  const anyTealAlive = Array.isArray(bubbles) && bubbles.some(b => b.alive && b.kind !== 'trick');

  if (currentMode === 'classic') {
    if (window.__classicRelax) {
      if (!anyTealAlive) {
        // e.g., tiny difficulty bump each refill (cap to keep fair)
        window.__relaxRefills = (window.__relaxRefills || 0) + 1;
        // example: nudge trick rate a hair every 2 refills (bounded)
        const bump = Math.min(0.04, (Math.floor(window.__relaxRefills/2) * 0.01));
        window.__dynamicRedRate = Math.min(0.25, (RED_RATE || 0.15) + bump);

        // Refill the static grid and continue (no Game Over)
        buildClassicBoard();          // reuse your existing builder
        // ensure UI stays consistent
        refreshQuitBtn?.();
      }
    } else {
      // Timed variant: still end when all teal are gone OR time expires
      if (!anyTealAlive) endGame();
      if (classicDeadline && Date.now() >= classicDeadline) endGame();
    }
  }  

  if (currentMode !== 'classic' || !window.__classicStatic){ /* move */ }

} // end of draw()